use crate::valuation::Valuation;

use super::*;
use algebraeon_nzq::Natural;
use algebraeon_sets::structure::*;

pub trait DedekindDomainSignature: IntegralDomainSignature {}

pub trait RingToIdealsSignature: RingSignature {
    type Ideals<SelfB: BorrowedStructure<Self>>: IdealsSignature<Self, SelfB>;
    fn ideals<'a>(&'a self) -> Self::Ideals<&'a Self>;
    fn into_ideals(self) -> Self::Ideals<Self>;
}
pub trait MetaCanonicalIdealsSignature: MetaType
where
    Self::Signature: RingToIdealsSignature,
{
    fn ideals() -> <Self::Signature as RingToIdealsSignature>::Ideals<Self::Signature> {
        Self::structure().into_ideals()
    }
}
impl<R: MetaType> MetaCanonicalIdealsSignature for R where R::Signature: RingToIdealsSignature {}

pub trait IdealsSignature<Ring: RingSignature, RingB: BorrowedStructure<Ring>>:
    SetSignature
{
    fn ring(&self) -> &Ring;
}

// pub trait MetaIdealSignature<Ring: RingSignature>: MetaType
// where
//     Self::Signature: IdealSignature<Ring>,
// {
// }
// impl<R: MetaType, Ring: RingSignature> MetaIdealSignature<Ring> for R where
//     Self::Signature: IdealSignature<Ring>
// {
// }

pub trait IdealsArithmeticSignature<Ring: RingSignature, RingB: BorrowedStructure<Ring>>:
    IdealsSignature<Ring, RingB>
{
    // The zero ideal i.e. contains only 0
    fn zero_ideal(&self) -> Self::Set {
        self.principal_ideal(&self.ring().zero())
    }

    // The unit ideal i.e. contains everything
    fn unit_ideal(&self) -> Self::Set {
        self.principal_ideal(&self.ring().one())
    }

    /// The ideal generated by a list of elements
    fn generated_ideal(&self, elems: Vec<impl Into<Ring::Set>>) -> Self::Set {
        self.ideal_sum(
            elems
                .into_iter()
                .map(|elem| self.principal_ideal(&elem.into()))
                .collect(),
        )
    }

    /// The principal ideal generated by a
    fn principal_ideal(&self, a: &Ring::Set) -> Self::Set;

    /// Are the ideals equal?
    fn ideal_equal(&self, a: &Self::Set, b: &Self::Set) -> bool {
        self.ideal_contains(a, b) && self.ideal_contains(b, a)
    }

    /// Is the ideal the zero ideal
    fn ideal_is_zero(&self, a: &Self::Set) -> bool {
        self.ideal_equal(a, &self.zero_ideal())
    }

    /// Does a contain b i.e. does a divide b
    fn ideal_contains(&self, a: &Self::Set, b: &Self::Set) -> bool;

    /// Does a contain x
    fn ideal_contains_element(&self, a: &Self::Set, x: &Ring::Set) -> bool {
        self.ideal_contains(a, &self.principal_ideal(x))
    }

    /// Intersection of ideals
    fn ideal_intersect(&self, a: &Self::Set, b: &Self::Set) -> Self::Set;

    /// Sum of two ideals
    fn ideal_add(&self, a: &Self::Set, b: &Self::Set) -> Self::Set;

    /// Sum of many ideals
    fn ideal_sum(&self, ideals: Vec<impl Into<Self::Set>>) -> Self::Set {
        let mut total = self.zero_ideal();
        for i in ideals {
            total = self.ideal_add(&total, &i.into());
        }
        total
    }

    /// Product of two ideals
    fn ideal_mul(&self, a: &Self::Set, b: &Self::Set) -> Self::Set;

    /// Sum of many ideals
    fn ideal_product(&self, ideals: Vec<impl Into<Self::Set>>) -> Self::Set {
        let mut total = self.unit_ideal();
        for i in ideals {
            total = self.ideal_mul(&total, &i.into());
        }
        total
    }

    /// ideal to a natural power
    fn ideal_nat_pow(&self, ideal: &Self::Set, n: &Natural) -> Self::Set {
        if *n == Natural::ZERO {
            self.unit_ideal()
        } else if *n == Natural::ONE {
            ideal.clone()
        } else {
            debug_assert!(*n >= Natural::TWO);
            let bits: Vec<_> = n.bits().collect();
            let mut pows = vec![ideal.clone()];
            while pows.len() < bits.len() {
                pows.push(self.ideal_mul(pows.last().unwrap(), pows.last().unwrap()));
            }
            let count = bits.len();
            debug_assert_eq!(count, pows.len());
            let mut ans = self.unit_ideal();
            for i in 0..count {
                if bits[i] {
                    ans = self.ideal_mul(&ans, &pows[i]);
                }
            }
            ans
        }
    }
}

pub trait PrincipalIdealsSignature<Ring: RingSignature, RingB: BorrowedStructure<Ring>>:
    IdealsSignature<Ring, RingB>
{
    fn ideal_generator(&self, ideal: &Self::Set) -> Ring::Set;
}

/// A ring in which all ideals uniquely factor as a product of powers of prime ideals
pub trait DedekindDomainIdealsSignature<
    Ring: DedekindDomainSignature,
    RingB: BorrowedStructure<Ring>,
>: IdealsArithmeticSignature<Ring, RingB>
{
    /// Return the largest power of `prime_ideal` which divides `ideal`
    fn largest_prime_ideal_factor_power(
        &self,
        prime_ideal: &DedekindDomainPrimeIdeal<Self::Set>,
        ideal: &Self::Set,
    ) -> Natural {
        debug_assert!(!self.ideal_equal(prime_ideal.ideal(), &self.unit_ideal()));
        let mut k = Natural::ZERO;
        let mut prime_ideal_to_the_k_plus_one = prime_ideal.ideal().clone();
        while self.ideal_contains(&prime_ideal_to_the_k_plus_one, ideal) {
            k += Natural::ONE;
            prime_ideal_to_the_k_plus_one =
                self.ideal_mul(&prime_ideal_to_the_k_plus_one, prime_ideal.ideal());
        }
        k
    }

    /// return the valuation of an element `a` with respect to an ideal `I`
    /// this is the largest power `k` such that `I^k` contains `a`
    fn padic_r_element_valuation(
        &self,
        prime: &DedekindDomainPrimeIdeal<Self::Set>,
        a: &Ring::Set,
    ) -> Valuation {
        debug_assert!(self.ring().is_element(a).is_ok());
        debug_assert!(self.is_element(prime.ideal()).is_ok());
        if self.ring().is_zero(a) {
            return Valuation::Infinity;
        }
        let mut k = 1usize;
        let mut prime_to_the_k = prime.ideal().clone();
        loop {
            if !self.ideal_contains_element(&prime_to_the_k, a) {
                return Valuation::Finite((k - 1).into());
            }
            k += 1;
            prime_to_the_k = self.ideal_mul(&prime_to_the_k, prime.ideal());
        }
    }

    /// return the valuation of an ideal `a` with respect to an ideal `I`
    /// this is the largest power `k` such that `I^k` contains `a`
    fn padic_r_ideal_valuation(
        &self,
        prime: &DedekindDomainPrimeIdeal<Self::Set>,
        a: &Self::Set,
    ) -> Valuation {
        debug_assert!(self.is_element(a).is_ok());
        debug_assert!(self.is_element(prime.ideal()).is_ok());
        if self.ideal_is_zero(a) {
            return Valuation::Infinity;
        }
        let mut k = 1usize;
        let mut prime_to_the_k = prime.ideal().clone();
        loop {
            if !self.ideal_contains(&prime_to_the_k, a) {
                return Valuation::Finite((k - 1).into());
            }
            k += 1;
            prime_to_the_k = self.ideal_mul(&prime_to_the_k, prime.ideal());
        }
    }
}

pub trait FactorableIdealsSignature<Ring: DedekindDomainSignature, RingB: BorrowedStructure<Ring>>:
    DedekindDomainIdealsSignature<Ring, RingB>
{
    fn factorizations<'a>(
        &'a self,
    ) -> DedekindDomainIdealFactorizationStructure<Ring, RingB, Self, &'a Self> {
        DedekindDomainIdealFactorizationStructure::new(self)
    }

    fn into_factorizations(
        self,
    ) -> DedekindDomainIdealFactorizationStructure<Ring, RingB, Self, Self> {
        DedekindDomainIdealFactorizationStructure::new(self)
    }

    fn factor_ideal(
        &self,
        ideal: &Self::Set,
    ) -> Option<DedekindDomainIdealFactorization<Self::Set>>;

    fn is_prime_ideal(&self, ideal: &Self::Set) -> bool {
        if let Some(f) = self.factor_ideal(ideal) {
            self.factorizations().is_prime(&f)
        } else {
            false
        }
    }
}
