use super::*;
use crate::valuation::Valuation;
use algebraeon_nzq::{Natural, NaturalCanonicalStructure};
use algebraeon_sets::structure::*;

pub trait DedekindDomainSignature: IntegralDomainSignature {}

pub trait RingToIdealsSignature: RingSignature {
    type Ideals<SelfB: BorrowedStructure<Self>>: IdealsSignature<Self, SelfB>;

    fn ideals(&self) -> Self::Ideals<&Self>;
    fn into_ideals(self) -> Self::Ideals<Self>;
}
pub trait MetaCanonicalIdealsSignature: MetaType
where
    Self::Signature: RingToIdealsSignature,
{
    fn ideals() -> <Self::Signature as RingToIdealsSignature>::Ideals<Self::Signature> {
        Self::structure().into_ideals()
    }
}
impl<R: MetaType> MetaCanonicalIdealsSignature for R where R::Signature: RingToIdealsSignature {}

pub trait IdealsSignature<Ring: RingSignature, RingB: BorrowedStructure<Ring>>:
    SetSignature
{
    fn ring(&self) -> &Ring;
}

pub trait IdealsArithmeticSignature<Ring: RingSignature, RingB: BorrowedStructure<Ring>>:
    IdealsSignature<Ring, RingB> + SemiRingEqSignature
{
    /// The ideal generated by a list of elements
    fn generated_ideal(&self, elems: Vec<impl Into<Ring::Set>>) -> Self::Set {
        self.sum(
            elems
                .into_iter()
                .map(|elem| self.principal_ideal(&elem.into()))
                .collect(),
        )
    }

    /// The principal ideal generated by a
    fn principal_ideal(&self, a: &Ring::Set) -> Self::Set;

    /// Does a contain b i.e. does a divide b
    fn contains_ideal(&self, a: &Self::Set, b: &Self::Set) -> bool;

    /// Does a contain x
    fn contains_element(&self, a: &Self::Set, x: &Ring::Set) -> bool {
        self.contains_ideal(a, &self.principal_ideal(x))
    }

    /// Intersection of two ideals
    fn intersect(&self, a: &Self::Set, b: &Self::Set) -> Self::Set;

    /// The quotient of ideals (I : J) = {ring elements x such that xJ is a subset of I}
    fn quotient(&self, i: &Self::Set, j: &Self::Set) -> Self::Set;
}

pub trait PrincipalIdealsSignature<Ring: RingSignature, RingB: BorrowedStructure<Ring>>:
    IdealsSignature<Ring, RingB>
{
    fn ideal_generator(&self, ideal: &Self::Set) -> Ring::Set;
}

/// A ring in which all ideals uniquely factor as a product of powers of prime ideals
pub trait DedekindDomainIdealsSignature<
    Ring: DedekindDomainSignature,
    RingB: BorrowedStructure<Ring>,
>:
    IdealsArithmeticSignature<Ring, RingB>
    + UniqueFactorizationMonoidSignature<FactoredExponent = NaturalCanonicalStructure>
{
    /// Return the largest power of `prime_ideal` which divides `ideal`
    fn largest_prime_ideal_factor_power(
        &self,
        prime_ideal: &Self::Set,
        ideal: &Self::Set,
    ) -> Natural {
        debug_assert!(!self.equal(prime_ideal, &self.one()));
        let mut k = Natural::ZERO;
        let mut prime_ideal_to_the_k_plus_one = prime_ideal.clone();
        while self.contains_ideal(&prime_ideal_to_the_k_plus_one, ideal) {
            k += Natural::ONE;
            prime_ideal_to_the_k_plus_one = self.mul(&prime_ideal_to_the_k_plus_one, prime_ideal);
        }
        k
    }

    /// return the valuation of an element `a` with respect to an ideal `I`
    /// this is the largest power `k` such that `I^k` contains `a`
    fn padic_r_element_valuation(&self, prime: &Self::Set, a: &Ring::Set) -> Valuation {
        debug_assert!(self.ring().validate_element(a).is_ok());
        debug_assert!(self.validate_element(prime).is_ok());
        if self.ring().is_zero(a) {
            return Valuation::Infinity;
        }
        let mut k = 1usize;
        let mut prime_to_the_k = prime.clone();
        loop {
            if !self.contains_element(&prime_to_the_k, a) {
                return Valuation::Finite((k - 1).into());
            }
            k += 1;
            prime_to_the_k = self.mul(&prime_to_the_k, prime);
        }
    }

    /// return the valuation of an ideal `a` with respect to an ideal `I`
    /// this is the largest power `k` such that `I^k` contains `a`
    fn padic_r_ideal_valuation(&self, prime: &Self::Set, a: &Self::Set) -> Valuation {
        debug_assert!(self.validate_element(a).is_ok());
        debug_assert!(self.validate_element(prime).is_ok());
        if self.is_zero(a) {
            return Valuation::Infinity;
        }
        let mut k = 1usize;
        let mut prime_to_the_k = prime.clone();
        loop {
            if !self.contains_ideal(&prime_to_the_k, a) {
                return Valuation::Finite((k - 1).into());
            }
            k += 1;
            prime_to_the_k = self.mul(&prime_to_the_k, prime);
        }
    }
}
